const aaa = true,
      bbb = true;
if (aaa && bbb) {
console.log("Я сыт!");
}

console.log((aaa && bbb));
// 7 стр обращается к стр 3, т.к. обе переменные true, то выполняется условие 3ей строчки и в консоль выводится "Я сыт!" + команда 7ой строчки выводит true, если бы одна из переменных была false, то команда с 4ой стр не выодиться, а команда с 7ой отображает false
// ___________________________________________________________________________________________________________________________
//                                       5 элементов в JS, которые всегда имеют значение FALSE
// 0 - ноль;
// пустая строка '', ' ' - это уже не пустая строка, в ней есть пробел
// null - то, чего не существует в этом файле (19 стр в scr 11)
// undefined - когда переменная не имеет какого-либо значения (scr 11 с 23 по 26 стр)
// NaN (not a number) - можно посмотреть в scr 11 4я и 6я строки (умножение строки на число)
//             ВСЕ ОСТАЛЬНЫЕ ВАРИАНТЫ ВСЕГДА БУДУТ TRUE
// ___________________________________________________________________________________________________________________________
// ВАЖНЫЙ ПРИМЕР, здесь объясняется тонкость булинового условия, условия в котором упор на правду или ложь
const bread = 2,
      eggs = 1;
if (bread === 3 && eggs) {
console.log("Все сыты");
} else {
  console.log("Голод");
}
// идея такая: 3 человека хотят хлеб, а ты яйцо. В данном случае не обязательно прописывать в условии количесвто яиц, главное, чтобы хотя бы одно было в наличии. В заведении в наличии 2 хлеба и 1 яйцо
// также нельзя забывать про ПРИОРИТЕТ выполнения операторов, т.к. === занимает в таблице приоритетов 10 место, а && - 6ое, то сначала будет выполняться строгое сравнение
// чтение стр 19-24: хлеб равен 3? - нет, значит "bread === 3" - false, дальше "bread === 3" и eggs правда? - нет
// хоть у нас и есть переменная eggs, которая равна 1 и по сути является true, у нас есть bread, которая не выполняется условие количества, поэтому в скобках ситуация такая: (bread === 3 && eggs) - (false && true), а значит условия для фразы "Все сыты" не выполняется и тогда применяется фраза "Голод"
// _____________________________________________________________________________________________________________________
//                           важная информация по оператору &&
// Данный оператор останавливает выполнение кода после первого столкновения с false и выдает его в консоли
// Либо, если все условия выполнены, в консоль выведет значение последнего положительного аргумента, если в условии для него не было прописанно конкретное значение
const a = 2,
      b = 0,
      c = 5,
      d = 7;

console.log(a === 2 && b && c === 5 && d === 7);
// здесь остановка поизошла на "b" и результат - 0, т.к. данная переменная имеет значение 0, который всегда читается как false
// если же переменной 'b' задать цифру, которая не будет соответствовать цифре прописанной в условии, то в консоли увидим false
const aa = 2,
      bb = 1,
      cc = 5,
      dd = 7;

console.log(aa === 2 && bb && cc === 5 && dd);
// здесь в консоли увидим 7, т.к. здесь все условия выполнены и по последнему аргументу не была задано определенное значение переменной "d", поэтому оператор вывел в консоли то, чему равна эта переменная
// если же в условии прописать dd === 7, то оператор && выведет в консоль true

// еще наглядные примеры
console.log(1 && 0);
console.log(2 && 5);
console.log(null && 3);
console.log(0 && 'lol');
// 0
// 5
// null - один из пяти вечно лживых элементов, и т.к. он стоял первым, то оператор сразу вывел его и прекратил все процессы
// 0
// ________________________________________________________________________________________________________________________
//                              аналогичный нюанс у оператора ||
// он будет останавливать проверку всех условий, как только встретит первый правдивый аргумент, т.к. ему для работы достаточно наличие одного правдивого аргумента
// если же все аргументы будут false, то оператор || (или) вернет в консоль последнее ложное значение
const kek = 2,
      chek = 0,
      hek = 0;
if (kek || chek || hek) {
console.log("Топ");
} else {
  console.log("Не топ");
}
console.log(kek || chek || hek);
// т.к. оператор || с первого же аргумента наткнулся на правду, и аргументу не было заданно определенное значение, то в консоли 2
const q = 0,
      w = 0,
      e = null;
if (q || w || e) {
console.log("Топ");
} else {
  console.log("Не топ");
}
console.log(q || w || e);
// результатом IF будет 'не топ', а результатом конслога - null, т.к. значение последнего отрицательного аргумента именно null

// применение такого комплекса операторов (if, &&, ||) помогает в массиве данных вычислить, что хотя бы где-то в нем есть то, что нам нужно

// пример: сотрудники должны сдать отчеты, и допустим если хотя бы у одного из них он сдан, то отправить его дальше

let max, olga, mixa, maga = 'done'; 
// иной вариант записи:
// let max,
//     olga,
//     mixa,
//     maga = 'done'; иначе говоря у первых 3х переменных - undefined (false), а в последней переменной лежит строчка

console.log(max || olga || mixa || maga);
// т.к. хотя бы мага сдал отчет, то оператор || выведет в консоль done, ведь мага это первый правдивый аргумент в условии
// ______________________________________________________________________________________________________________________
//                               комбинация операторов
const hamburger = 3,
      fries = 3,
      cola = 0,
      naggets = 2;

if (hamburger === 3 && cola === 2 || fries === 3 && naggets) {
console.log("Топ");
} else {
  console.log("Не топ");
}

console.log(hamburger === 3 && cola === 2 || fries === 3 && naggets);
// в условии следующая ситуация: нужно чтобы в наличии было 3 бургера и 2 колы или же 3 картошки и 1 наггетс
// очередность операторов: в таблице операторов 10ое место - ===, 6ое - &&, 5ое - ||, поэтмоу сначала ===, потом &&, и наконец ||
// результат:
// Топ
// 2
// _________________________________________________________________________________________________________________________
//                                      первостепенный оператор () - группировка
// Занимает 20ое место в таблице и имеет главный приоритет над всеми операторами
console.log(hamburger === 3 && (cola === 2 || fries === 3) && naggets);

// порядок операторов теперь здесь будет другой, сначала то, что во внутренних скобках, а потом уже во внешних
// _________________________________________________________________________________________________________________________
//                            еще пример по оператору ! - "не" или отрицание
console.log(!0);
// 0 - по умолчанию false, но оператор отрицания 0 из false превратит в true